<!--
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.
-->

<!--
    Copyright (c) 2016, Joyent, Inc.
-->

# mdb_v8 Developer's Notes

## Contribution guidelines

Contributions are welcome, but please help us review your changes (and keep code
quality high) by following these guidelines.  **If you have any questions, feel
free to ask.**  Don't let these guidelines be a barrier to contributing!

**This repository does not use GitHub pull requests.**  Changes should be
submitted through
[cr.joyent.us](https://github.com/joyent/joyent-gerrit/tree/master/docs/user).

**Use of GitHub issues:** There should be at least one GitHub issue filed for
your change (even trivial changes).  This issue should explain the change, the
impact on users, how you've tested it, and any other information that reviewers
might need to know about the change.  (Do not put this text in the commit
message.  See below.)  If you're not sure exactly what change you want to make,
feel free to create an issue to discuss it.

**Commit messages:** The commit message should consist of one line per
associated issue, each line consisting of the issue number and issue synopsis.
See previous commit messages for examples.  There should be no other text in the
commit message.  Other information related to the change should generally be in
the GitHub issue comments.

**Completeness:** Changes should include relevant updates to the documentation,
including CHANGES.md.  New commands, walkers, and non-private options must have
associated documentation, both in the dmod (so that "::help DCMD" works) and in
the usage guide.

**Testing**: All changes should be `make prepush` clean, but additional testing
is probably necessary for most changes.  See below.

Once you've got a change ready to integrate, you can submit it to cr.joyent.us
using the [cr.joyent.us user
instructions](https://github.com/joyent/joyent-gerrit/tree/master/docs/user).
Feel free to reach out to past contributors to ask them to review your change.
Review and integration happen through the cr.joyent.us interface.


## Testing

The appropriate level of testing depends on the scope of the change.  Any
non-trivial changes should be tested on:

- core files from each of the latest several major releases of Node
  (e.g., Node v4, Node v0.12, and Node v0.10)
- core files from both 32-bit and 64-bit programs
- core files generated by abort(3c) and core files generated by gcore(1M)

Depending on the change, you may want to test it manually on an existing
collection of representative core files.  If you're not sure about test
requirements, please ask.


### Automated testing

The automated tests are not a comprehensive regression test suite.  Think of
them more as a smoke test.  You can run them by running:

- `make test` (which is run by `make prepush`)
- the `catest` tool, which lets you run individual tests separately
- any of the individual tests by hand (they're standalone programs), which is
  likely easier for debugging the tests

All of these approaches use whichever Node is on your PATH to run a Node program
and generate core files of that program.  Your local build of mdb\_v8 is used to
inspect it.


### Automated testing across different Node versions and architectures

For coverage across 32-bit and 64-bit and multiple Node versions, you can use
the `runtests_node` tool:

1. First, run `runtests_node setup SOME_DIRECTORY`, which downloads the
   supported Node versions into "SOME\_DIRECTORY".
2. Then, run `runtests_node run SOME_DIRECTORY`, which executes the full test
   suite on each of the versions in the directory.

Because we've made it pretty straightforward, we expect all changes to pass the
test suite on all of the versions and architectures used by `runtests_node`.


### Memory leak testing

mdb runs with libumem, which means it's easy to check for memory leaks in C
code.  The process basically looks like this:

1. Open up MDB on a core file and load mdb\_v8.
2. Exercise as much mdb\_v8 functionality as you can (or whatever functionality
   you're trying to test for leaks.
3. _On platforms before illumos issue
   [6338](https://www.illumos.org/issues/6338) was fixed (which is all platforms
   before 2015-10-26)_, run: `::unload libumem.so`.  This is the easiest way to
   work around that issue.
4. Use `gcore` to save a core file of your MDB process.
5. Open up that core file in MDB.  (Yes, this gets confusing: you're using MDB
   to look at a core file of MDB looking at a core file of a Node program.)
6. Run `findleaks -v` to look for leaks.

There's a lot more information about using libumem to debug memory leaks
elsewhere on the web.


### Stress testing

There's a [dumpjsobjects](../tools/dumpjsobjects) tool that takes a core file
and an mdb\_v8 binary and uses `findjsobjects` and `jsprint` to enumerate all of
the objects in a deterministic order and print them out.  With a representative
core file, this is a decent coverage test, since it will likely exercise the
paths for interpreting most types of supported objects.  At the very least, this
should not crash.


### Comparing output across mdb_v8 changes

For some kinds of changes, it's worthwhile to spend time comparing output from
before the change with output after the change to make sure you haven't
introduced any new issues.  The `mdbv8diff` tool can be used to compare the
`dumpjsobjects` output from two different versions of mdb\_v8.

Why not just use `diff(1)`?  The challenge is that many changes to mdb\_v8
change the output format slightly or fix nitty bugs that affect a large number
of objects.  `diff` can easily produce hundreds of thousands of lines of output,
but there may be only a handful of different _kinds_ of changes, and they may
all be easy to programmatically identify (e.g., the wording of a particular
error message changed).  For this reason, `mdbv8diff` provides a small "ignore"
module interface, where you define a function that takes two lines of output
that look different and decides whether the difference corresponds exactly to an
expected change.  Sometimes, a diff represents something that's hard to
programmatically recognize but you've manually confirmed that it's correct.  You
can also add specific values as special cases to ignore.  (These obviously
depend on the specific core file you're debugging.)

The intended workflow is that you run `mdbv8diff` on output from before and
after your change.  It likely finds tons of diffs.  You create a small "ignore"
module.  As you go through the diffs one-by-one, if the diff represents a
regression, you fix your code.  If the diff represents an expected change, you
teach your "ignore" module how to recognize it.  You keep iterating this process
until `mdbv8diff` produces no more output.

This is obviously pretty crude.  Think of this as a tool to assist the otherwise
manual effort of exhaustively comparing lots of output, not an efficient
regression tester.

The "ignore" modules for past changes are committed to the repo for reference,
though they likely wouldn't be reused except to reproduce the original testing
work for the change.

## Building node for debugging with gdb

While working on this module, it may be helpful to be able to use gdb to look at
C++ objects.  The node build needs three things:

- gdb support
- debug support
- postmortem debugging symbols

The first two come by way of flags to `configure`.  The last requires a bit of
help in the form of this patch.

```patch
diff --git a/node.gypi b/node.gypi
index 82953ee9ff..083f22cd40 100644
--- a/node.gypi
+++ b/node.gypi
@@ -102,6 +102,15 @@
               '-Wl,-force_load,<(v8_base)',
             ],
           },
+          'conditions': [
+            ['OS!="aix" and node_shared=="false"', {
+              'ldflags': [
+                '-Wl,--whole-archive,<(obj_dir)/deps/v8/src/'
+                   '<(STATIC_LIB_PREFIX)v8_base<(STATIC_LIB_SUFFIX)',
+                '-Wl,--no-whole-archive',
+              ],
+            }],
+         ],
         }],
       ],
     }],
```

These steps should get you on your way for Node v8.12.0 in a SmartOS 20181804
zone.

```
$ export PATH=/opt/local/gcc8/bin:/opt/local/bin:$PATH
$ pfexec pkgin -y install git gmake gcc8
$ git clone git@github.com:mgerdts/node.git
$ cd node
$ git checkout v8.12.0-mgerdts
$ ./configure --debug --gdb
$ gmake -j 4
```

When that finishes you should have symlinks to two executables: `node`
(release) and `node\_g` (debug).

Once you do that you can poke around at the underlying C++ objects.

```
$ PS1='\n\u@\w $ '

mgerdts@~/mdb_v8 $ ~/node/node_g
>
[1]+  Stopped                 ~/node/node_g

mgerdts@~/mdb_v8 $ jobs -l
[1]+ 372931 Stopped (user)          ~/node/node_g

mgerdts@~/mdb_v8 $ mdb -L $(pwd)/build/amd64 -p 372931
> ::load mdb_v8
mdb_v8 version: 1.4.0 (dev)
V8 version: 6.2.414.66
Autoconfigured V8 support from target
C++ symbol demangling enabled
> ::findjsobjects
          OBJECT #OBJECTS   #PROPS CONSTRUCTOR: PROPS
    3bf37f139681        1        0 Domain
    3bf37f1479c1        1        0 ReadFileContext
...
> ::gcore
mdb: core.372931 dumped
> ^Z

[2]+  Stopped                 mdb -L $(pwd)/build/amd64 -p 372931
```

Now that we have the addresses of some objects, let's look at them from the C++
side.  The magic here is to use `print *(v8::internal::JSObject *)0x` followed
by the address of an object.

```
mgerdts@~/mdb_v8 $ gdb ~/node/node_g core.372931
GNU gdb (GDB) 7.11
...
warning: Unexpected size of section `.reg2/1' in core file.
#0  0xfffffbffef2161fa in kill () from /lib/64/libc.so.1
[Current thread is 11 (Thread 1 (LWP 1))]
(gdb) set print pretty on
(gdb) print *(v8::internal::JSObject *)0x3bf37f139681
$1 = {
  <v8::internal::JSReceiver> = {
    <v8::internal::HeapObject> = {
      <v8::internal::Object> = {
        static kHeaderSize = 0
      },
      members of v8::internal::HeapObject:
      static kMapOffset = 0,
      static kHeaderSize = 8
    },
    members of v8::internal::JSReceiver:
    static kHashMask = 2147482624,
    static kPropertiesOrHashOffset = 8,
    static kHeaderSize = 16
  },
  members of v8::internal::JSObject:
  static kMinAddedElementsCapacity = 16,
  static kMaxElementCount = 4294967295,
  static kMaxGap = 1024,
  static kMaxUncheckedFastElementsLength = 5000,
  static kMaxUncheckedOldFastElementsLength = 500,
  static kInitialGlobalObjectUnusedPropertiesCount = 4,
  static kMaxInstanceSize = 2040,
  static kFieldsAdded = 3,
  static kElementsOffset = 16,
  static kHeaderSize = 24,
  static kMaxInObjectProperties = 252
}
(gdb)
...
